---
title: "GLMM IRWLS Demonstration"
author: "Mukai Wang"
date: "7/21/2022"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
folder = '/home/wangmk/UM/Research/MDAWG/DiffRatio/RMD'
source(file.path(folder, 'ANCOM.R'))
source(file.path(folder, 'preprocess.R'))
library(ggplot2)
library(lme4)
```

# Simulated Data

I first simulate a small dataset to test if I understand the IRWLS algorithm correctly. I prepare 100 data points. Each data point has two binary covariates. Their effect sizes are 1.2 and -1.3 accordingly. The random intercepts are generated from a mixture of $N(-2, 0.4)$ and $N(2, 0.4)$.

```{r}
set.seed(2022)
sythetic_effsizes <- c(1.2, -1.3)
covariate_mat <- cbind(rbinom(100, 1, 0.5), rbinom(100, 1, 0.5))

### random effects generated from two Gaussian mixtures
mixcomp1 <- rnorm(100, mean=-2, sd=0.4)
mixcomp2 <- rnorm(100, mean=2, sd=0.4)
selector <- rbinom(100, 1, prob=0.5)
randeff <- rep(0, 100)
randeff[selector == 0] <- mixcomp1[selector == 0]
randeff[selector == 1] <- mixcomp2[selector == 1]

logodds <- 0.05 + covariate_mat %*% sythetic_effsizes + randeff
prob <- 1 / (1 + exp(-logodds))
population <- floor(runif(100, min=10, max=25))
ID <- seq(1, 100)
positive <- rep(0, length(ID))
negative <- rep(0, length(ID))
for (j in 1:length(ID)){
  positive[j] <- rbinom(1, population[j], prob[j])
  negative[j] <- population[j] - positive[j]
}
df <- cbind(ID, covariate_mat, positive, negative) %>% as.data.frame()
colnames(df) <- c('ID', 'X1', 'X2', 'Positive', 'Negative')

knitr::kable(head(df))
```

```{r, echo=FALSE, out.width="60%"}
ggplot(df, aes(x=Positive, y=Negative)) + geom_point() +
  theme_bw()
```


First run the `glmer` function. Remember that `lme4` supports multiple settings. I run both the PIRLS(`nAGQ`=0) and Laplace approximation(`nAGQ`=1). 

```{r}
glmermodel_LA <- glmer(cbind(Positive, Negative) ~ X1 + X2 + (1|ID), 
                    data=df, family="binomial", nAGQ=1)
glmermodel_PIRLS <- glmer(cbind(Positive, Negative) ~ X1 + X2 + (1|ID), 
                    data=df, family="binomial", nAGQ=0)
```


Then let's code up IRWLS. Note that because we are iteratively running linear mixed model, we need to transform the data into long format first.

```{r}
short2long <- function(shortdf, count_cols){

  covar_df <- shortdf[, !names(shortdf) %in% count_cols]

  cnames <- c(colnames(covar_df), 'Y')
  longdf <- data.frame(matrix(ncol = length(cnames), nrow=0))
  colnames(longdf) <- cnames

  counts_df <- shortdf[, count_cols]
  freq <- rep(0, nrow(counts_df))
  for (j in 1:nrow(counts_df)){
    pos_count <- counts_df[j, count_cols[1]]
    neg_count <- counts_df[j, count_cols[2]]
    if (pos_count + neg_count == 0) next
    freq[j] <- pos_count + neg_count
    Y <- c(rep(1, pos_count), rep(0, neg_count))
    repeat_covars <- covar_df[rep(j, pos_count+neg_count), ]
    longdf <- rbind(longdf, cbind(repeat_covars, Y))
  }
  freq <- freq[freq!=0]
  return(list(longdf, freq))
}
```

Then comes the details of the IRWLS algorithm. We first run GLM to get initial fixed effects to start from. Then we apply iteratively linear mixed effects model to update the fixed effects and the random effects.

```{r}
IRWLS <- function(taxa_pairs, covariates, level,  data){
  # generate long format
  clean_data <- short2long(data, taxa_pairs)
  long_df <- clean_data[[1]]
  freq <- clean_data[[2]]
  long_df[[level]] <- as.factor(long_df[[level]])

  # generate regression formula
  covariates_sum <- paste(covariates, collapse='+')
  reffect <- sprintf('(1|%s)', level)
  regfml_glm <- formula(sprintf("%s %s", 'Y ~', covariates_sum))
  regfml_lmm <- formula(sprintf("%s %s + %s", 'U ~', covariates_sum, reffect))

  # glm
  glm_model <- glm(regfml_glm, data=long_df, family="binomial")

  beta <- glm_model$coefficients
  b <- rep(0, length(unique(long_df[[level]])))
  t <- 0

  # Iteratively weighted LMM
  repeat{
    {
      eta <- beta[1] + rep(b, freq) +
        as.vector(as.matrix(long_df[, covariates]) %*% beta[-1])
      pi <- 1/(1+exp(-eta))
      weights <- pi*(1-pi)
      long_df$weight <- weights
      u_vec <- eta + (long_df$Y - pi) / weights
      long_df$U <- u_vec
      lmix_model <- lmer(regfml_lmm, data=long_df, 
                         weights = weight, REML=FALSE)
      new_beta <- fixef(lmix_model) %>% unname()
      b <- ranef(lmix_model)[[1]][[1]]
      t <- t+1
    };
    if(norm(new_beta - beta, type='2') < 0.000001 || t > 1000){
      beta <- new_beta
      final_model <- lmix_model
      break;
    } else{
      beta <- new_beta
    }
  }
  return(final_model)
}


IRWLS_model <- IRWLS(c('Positive', 'Negative'), c('X1', 'X2'), 'ID', df)
```

Compare the estimated fixed effects between the `glmer` and the IRWLS.

```{r, echo=FALSE}
get_pval <- function(tvar){
  0.5 - abs(0.5 - pnorm(tvar))
}

fixed_effects_summary <- function(model1){
  beta_1 <- fixef(model1) %>% unname()
  sd_1 <- vcov(model1) %>% diag() %>% sqrt()
  t_1 <- beta_1 / sd_1
  pval_1 <- get_pval(t_1)

  result <- cbind(beta_1, sd_1, pval_1) %>%
    as.data.frame()
  
  return(result)
}

simulation_result_glmer_LA <- fixed_effects_summary(glmermodel_LA)
simulation_result_glmer_PIRLS <- fixed_effects_summary(glmermodel_PIRLS)
simulation_result_IRWLS <- fixed_effects_summary(IRWLS_model)
simulation_result_comparison <- cbind(simulation_result_glmer_LA,
                                      simulation_result_glmer_PIRLS,
                                      simulation_result_IRWLS)

rownames(simulation_result_comparison) <- c("Intercept", "X1", 'X2')
colnames(simulation_result_comparison) <- c('glmer_LA_beta', 'glmer_LA_SD', 'glmer_LA_pval',
                                            'glmer_PIRLS_beta', 'glmer_PIRLS_SD', 'glmer_PIRLS_pval',
                                            'IRWLS_beta', 'IRWLS_SD', 'IRWLS_pval')

knitr::kable(t(simulation_result_comparison), digits=4)
```

As it turns out, the results are quite comparable. It means that my IRWLS implementation is correct. It's worthwhile to point out that my implementation of IRWLS has very similar outcome as the PIRLS outcome from `glmer` function.


# Real Data

Next let's take a look at the reaction of our IRWLS algorithm towards some real taxa pairs that the `glmer` function struggled.

## Saccharimonadales and Moraxella

```{r, echo=FALSE}
# load the data
load(file.path(file.path(folder, 'CAARS_data', 'CAARS_processed_GENUS.Rdata')))
processed_data <- preprocess(CAARS.data.genus, 'SAMPLE_ID', "asthma")


filtered_count <- processed_data$feature_table
filtered_metadata <- processed_data$meta_data
struc_zero <- processed_data$structure_zeros
covariates <- filtered_metadata[, c('SAMPLE_ID', 'asthma')]
```

The visualization of the counts is

```{r, echo=FALSE, out.width="60%"}
taxa_pair1 <- c("g__Saccharimonadales", "g__Moraxella" )
df1 <- cbind(covariates, t(filtered_count[taxa_pair1, ]))
df1_copy <- df1
df1_copy$asthma <- as.factor(df1_copy$asthma)
ggplot(df1_copy, aes(x=g__Moraxella, y=g__Saccharimonadales, color=asthma)) + geom_jitter(alpha=0.6) +
  theme_bw()
```


```{r, echo=FALSE, eval=FALSE}
contingency_table_test <- function(countdf, taxa_pair, group){
  group1_count <- countdf[countdf[[group]] == 0, ]
  group2_count <- countdf[countdf[[group]] == 1, ]
  
  taxon1 <- taxa_pair[1]
  taxon2 <- taxa_pair[2]
  group1_dbpos <- sum((group1_count[[taxon1]] > 0) & (group1_count[[taxon2]] > 0), na.rm=TRUE)
  group1_dbneg <- sum((group1_count[[taxon1]] == 0) & (group1_count[[taxon2]] == 0), na.rm=TRUE)
  group1_t1post2neg <- sum((group1_count[[taxon1]] > 0) & (group1_count[[taxon2]] == 0), na.rm=TRUE)
  group1_t1negt2pos <- sum((group1_count[[taxon1]] == 0) & (group1_count[[taxon2]] > 0), na.rm=TRUE)
  
  group2_dbpos <- sum((group2_count[[taxon1]] > 0) & (group2_count[[taxon2]] > 0), na.rm=TRUE)
  group2_dbneg <- sum((group2_count[[taxon1]] == 0) & (group2_count[[taxon2]] == 0), na.rm=TRUE)
  group2_t1post2neg <- sum((group2_count[[taxon1]] > 0) & (group2_count[[taxon2]] == 0), na.rm=TRUE)
  group2_t1negt2pos <- sum((group2_count[[taxon1]] == 0) & (group2_count[[taxon2]] > 0), na.rm=TRUE)
  
  ctable <- matrix(c(group1_dbpos, group1_dbneg, group1_t1post2neg, group1_t1negt2pos,
                                group2_dbpos, group2_dbneg, group2_t1post2neg, group2_t1negt2pos),
                              nrow=4)
  
  testresult <- fisher.test(ctable)
  
  return(list(ctable, testresult))
}

# outcome1 <- contingency_table_test(df1, c("g__Saccharimonadales", "g__Moraxella"), 'asthma')
# ctable1 <- outcome1[[1]] %>% as.data.frame()
# colnames(ctable1) <- c("Control", "Asthma")
# rownames(ctable1) <- c("Double Positive", "Double Negative", "T1PT2N", "T1NT2P")
# fishertest1 <- outcome1[[2]]
# knitr::kable(ctable1)
```


The effect sizes estimated by `glmer` is unreasonable. For the IRWLS, there is a singular warning that I need to look into later. Nevertheless, we don't see the same issue of extremely large/small effect sizes. The effect sizes are different between my implementation of IRWLS and the output from the PIRLS option of `glmer`, but the significance conclusion is the same.
```{r}
glmermodel1_LA <- glmer(cbind(g__Saccharimonadales, g__Moraxella) ~ asthma + (1|SAMPLE_ID),
                     data=df1, family="binomial", nAGQ=1)
glmermodel1_PIRLS <- glmer(cbind(g__Saccharimonadales, g__Moraxella) ~ asthma + (1|SAMPLE_ID),
                     data=df1, family="binomial", nAGQ=0)

# df1$SAMPLE_ID <- as.factor(df1$SAMPLE_ID)
# df1$asthma <- as.numeric(df1$asthma)
IRWLSmodel1 <- IRWLS(c('g__Saccharimonadales', 'g__Moraxella'), c('asthma'), 'SAMPLE_ID', df1)

taxa1_glmer_LA <- fixed_effects_summary(glmermodel1_LA)
taxa1_glmer_PIRLS <- fixed_effects_summary(glmermodel1_PIRLS)
taxa1_IRWLS <- fixed_effects_summary(IRWLSmodel1)

taxa1_comparison <- cbind(taxa1_glmer_LA, taxa1_glmer_PIRLS, taxa1_IRWLS)
rownames(taxa1_comparison) <- c("Intercept", "Asthma")
colnames(taxa1_comparison) <- c('glmer_beta', 'glmer_SD', 'glmer_pval',
                                'glmer_PIRLS_beta', 'glmer_PIRLS_SD', 'glmer_PIRLS_pval',
                                            'IRWLS_beta', 'IRWLS_SD', 'IRWLS_pval')

knitr::kable(t(taxa1_comparison), digits=4)
```



## Bifidobacterium and Butyrivibrio

The visualization of the counts is
```{r, echo=FALSE, out.width="60%"}
taxa_pair2 <- c('g__Streptobacillus', 'g__Kingella')
df2 <- cbind(covariates, t(filtered_count[taxa_pair2, ]))
df2_copy <- df2
df2_copy$asthma <- as.factor(df2_copy$asthma)
ggplot(df2_copy, aes(x=g__Kingella, y=g__Streptobacillus, color=asthma)) +
  geom_jitter(alpha=0.6) +
  theme_bw()
```


```{r, echo=FALSE, eval=FALSE}
outcome2 <- contingency_table_test(df2, taxa_pair2, 'asthma')
ctable2 <- outcome2[[1]] %>% as.data.frame()
colnames(ctable2) <- c("Control", "Asthma")
rownames(ctable2) <- c("Double Positive", "Double Negative", "T1PT2N", "T1NT2P")
fishertest2 <- outcome2[[2]]
knitr::kable(ctable2)
```


The `glmer` function sends out a warning and present an obviously miscalculated p value when under Laplace approximation setting. There is no warning under PIRLS setting or with my own version of IRWLS. The coefficient estimates are very similar between my implementation of IRWLS and the PIRLS setting of `glmer`.


```{r}
glmermodel2_LA <- glmer(cbind(g__Streptobacillus, g__Kingella) ~ asthma + (1|SAMPLE_ID),
                     data=df2, family="binomial", nAGQ=1)
glmermodel2_PIRLS <- glmer(cbind(g__Streptobacillus, g__Kingella) ~ asthma + (1|SAMPLE_ID),
                     data=df2, family="binomial", nAGQ=0)

IRWLSmodel2 <- IRWLS(c('g__Streptobacillus', 'g__Kingella'), c('asthma'), 'SAMPLE_ID', df2)

taxa2_glmer_LA <- fixed_effects_summary(glmermodel2_LA)
taxa2_glmer_PIRLS <- fixed_effects_summary(glmermodel2_PIRLS)
taxa2_IRWLS <- fixed_effects_summary(IRWLSmodel2)

taxa2_comparison <- cbind(taxa2_glmer_LA, taxa2_glmer_PIRLS, taxa2_IRWLS)

rownames(taxa2_comparison) <- c("Intercept", "Asthma")
colnames(taxa2_comparison) <- c('glmer_beta', 'glmer_SD', 'glmer_pval',
                                'glmer_PIRLS_beta', 'glmer_PIRLS_SD', 'glmer_PIRLS_pval',
                                            'IRWLS_beta', 'IRWLS_SD', 'IRWLS_pval')

knitr::kable(t(taxa2_comparison), digits=4)
```


# Comparison between ANCOM and GLMM with PIRLS

First run ANCOM.

```{r, message=FALSE}
main_var = "asthma"; p_adj_method = "BH"; alpha = 0.05
adj_formula = NULL; rand_formula =  NULL

ANCOM_start <- proc.time()
res = ANCOM(filtered_count, filtered_metadata, struc_zero, main_var, p_adj_method,
            alpha, adj_formula, rand_formula) # , lme_control)
ANCOM_duration <- proc.time() - ANCOM_start
ANCOM_pvals <- res$p_data

# organize all the p values into a long df

included_genus <- names(which(rowSums(struc_zero) == 0))
taxa_pairs <- combn(included_genus, 2) %>% t() %>% as.data.frame()
colnames(taxa_pairs) <- c("Taxa1", "Taxa2")
taxa_pairs$ANCOM <- 0

for (j in 1:nrow(taxa_pairs)){
  t1 <- taxa_pairs$Taxa1[j]
  t2 <- taxa_pairs$Taxa2[j]
  taxa_pairs$ANCOM[j] <- ANCOM_pvals[t1, t2]
}
taxa_pairs$ANCOM_adjusted <- p.adjust(taxa_pairs$ANCOM, method="BH")

```

Then run  `glmer` with PIRLS setting.

```{r}
library(DiffRatio)
result_file <- file.path(folder, 'CAARS_Model_Summary', 
                         'ANCOM_PIRLS_pval_comp.csv')
if(file.exists(result_file)){
  taxa_pairs <- read.csv(result_file)
} else{
  taxa_pairs$PIRLS <- 0
  PIRLS_start <- proc.time()
  
  PIRLS_failed_pairs <- c()
  for (j in 1:nrow(taxa_pairs)){
    tryCatch({
      t1 <- taxa_pairs$Taxa1[j]
      t2 <- taxa_pairs$Taxa2[j]
      glmm_PIRLS <- dfr(count_table=filtered_count, sample_info=filtered_metadata,
                         covar=c("asthma"), tpair=c(t1, t2), 
                      reff="SAMPLE_ID", taxa_are_rows = TRUE,
                         nAGQ = 0L, optimizer = "Nelder_Mead")
    }, warning = function(m){
      PIRLS_failed_pairs <<- c(PIRLS_failed_pairs, j)
    }, finally = {
      PIRLS_result <- fixed_effects_summary(glmm_PIRLS)
      taxa_pairs$PIRLS[j] <- PIRLS_result[2, 3]
    }
    )
  }
  
  PIRLS_duration <- proc.time() - PIRLS_start
  taxa_pairs$PIRLS_adjusted <- p.adjust(taxa_pairs$PIRLS, method='BH')
  write.csv(taxa_pairs, 
            file.path(folder, 'CAARS_Model_Summary', 'ANCOM_PIRLS_pval_comp.csv'),
            row.names = FALSE)
}
```


```{r, echo=FALSE}
ANCOM_positive_count_raw <- sum(taxa_pairs$ANCOM < 0.05)
PIRLS_positive_count_raw <- sum(taxa_pairs$PIRLS < 0.05)
ANCOM_positive_PIRLS_negative_count_raw <- sum(taxa_pairs$ANCOM < 0.05 &
                                                 taxa_pairs$PIRLS>0.05)
ANCOM_negative_PIRLS_positive_count_raw <- sum(taxa_pairs$ANCOM > 0.05 &
                                                 taxa_pairs$PIRLS < 0.05)

ANCOM_positive_count_adjusted <- sum(taxa_pairs$ANCOM_adjusted < 0.05)
PIRLS_positive_count_adjusted <- sum(taxa_pairs$PIRLS_adjusted < 0.05)

```


If we check the raw P values, ANCOM discovers `r ANCOM_positive_count_raw` pairs of taxa that are differentially abundant. GLMM with PIRLS setting discovers `r PIRLS_positive_count_raw` pairs of taxa that are differentially abundant. `r ANCOM_positive_PIRLS_negative_count_raw` pairs are only positive for ANCOM and negative for GLMM with PIRLS. `r ANCOM_negative_PIRLS_positive_count_raw` are negative for ANCOM and positive for GLMM with PIRLS. Surprisingly, after adjustment, ANCOM identifies `r ANCOM_positive_count_adjusted` pairs of differential taxa and GLMM with PIRLS identifies `r  PIRLS_positive_count_adjusted` pairs.

I decide to look at the `r ANCOM_positive_count_adjusted` pairs of taxa, provide scatter plots and refit differential analysis using my own version of IRWLS. During this process another issue popped up. When I fit my version of IRWLS to many pairs of taxa, the `lmer` function casts out warnings of "singular fit".


```{r}
taxa_pairs_subset <- taxa_pairs[which(taxa_pairs$ANCOM_adjusted < 0.05), ]
result_file_subset <- file.path(folder, 'CAARS_Model_Summary', 
                         'ANCOM_PIRLS_pval_comp_subset.csv')

if (file.exists(result_file_subset)){
  taxa_pairs_subset <- read.csv(result_file_subset)
} else{
  taxa_pairs_subset$IRWLS <- 0
  IRWLS_start <- proc.time()
  failed_rowid <- c()
  for (j in 1:nrow(taxa_pairs_subset)){
    t1 <- taxa_pairs_subset$Taxa1[j]
    t2 <- taxa_pairs_subset$Taxa2[j]
    selected_df <- cbind(covariates, t(filtered_count[c(t1, t2), ]))
    
    # plot
    output_fname <- file.path(folder, 'plots', sprintf('%s_%s.pdf', t1, t2))
    selected_df_copy <- selected_df
    selected_df_copy$asthma <- as.factor(selected_df_copy$asthma)
    scatter_plot <- ggplot(selected_df_copy, aes_string(x=t1, y=t2, color='asthma')) +
      geom_jitter(alpha=0.6) +
      theme_bw()
    ggsave(output_fname, scatter_plot, width=15, height=12, units='cm')
    
    outcome <- tryCatch({
      IRWLSmodel <- IRWLS(c(t1, t2),
                         c('asthma'), 'SAMPLE_ID', selected_df)
      IRWLS_result <- fixed_effects_summary(IRWLSmodel)
      taxa_pairs_subset$IRWLS[j] <- IRWLS_result[2, 3]
    },
      error=function(err){
        failed_rowid <<- c(failed_rowid, j)
        return(err)
      },
      warning=function(wrn){
        failed_rowid <<- c(failed_rowid, j)
        return(wrn)
      },
      message=function(msg){
        failed_rowid <<- c(failed_rowid, j)
        return(msg)
      }
    )
    if(inherits(outcome, "error")) next
    if(inherits(outcome, "warning")) next
    if(inherits(outcome, "message")) next
  }
IRWLS_duration <- proc.time() - IRWLS_start
taxa_pairs_subset$IRWLS_failure <- 0
taxa_pairs_subset$IRWLS_failure[failed_rowid] <- 1
write.csv(taxa_pairs_subset,
          file.path(folder, 'CAARS_Model_Summary', 'ANCOM_PIRLS_pval_comp_subset.csv'),
          row.names = FALSE)
}
```


